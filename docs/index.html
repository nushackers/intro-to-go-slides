
<!DOCTYPE html>
<html>
  <head>
    <title>Introduction to Go</title>
    <meta charset='utf-8'>
    <script>
      var notesEnabled =  false ;
    </script>
    <script src='./static/slides.js'></script>

    

    <script>
      
      if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
        var _gaq = _gaq || [];
        _gaq.push(["_setAccount", "UA-11222381-6"]);
        _gaq.push(["b._setAccount", "UA-49880327-6"]);
        window.trackPageview = function() {
          _gaq.push(["_trackPageview", location.pathname+location.hash]);
          _gaq.push(["b._trackPageview", location.pathname+location.hash]);
        };
        window.trackPageview();
        window.trackEvent = function(category, action, opt_label, opt_value, opt_noninteraction) {
          _gaq.push(["_trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
          _gaq.push(["b._trackEvent", category, action, opt_label, opt_value, opt_noninteraction]);
        };
      }
    </script>
  </head>

  <body style='display: none'>

    <section class='slides layout-widescreen'>

      <article>
        <h1>Introduction to Go</h1>
        <h3>Hackers Toolbox</h3>
        <h3>8 October 2024</h3>
        
          <div class="presenter">
            
  
  <p>
    Ravern Koh
  </p>
  

  
  <p>
    NUS Hackers
  </p>
  

          </div>
        
      </article>

  
  
      <article >
      
        <h3>Hello, world!</h3>
        <p>Welcome to <strong>Introduction to Go</strong>.</p>
<p>By the end of this workshop, you should be able to write your own simple Go programs with confidence.</p>
<p>We assume that you have basic programming knowledge, like some understanding of Python for example, but not much beyond that.</p>

      
      <span class="pagenumber">2</span>
      </article>
  
  
  
      <article >
      
        <h3>whoami</h3>
        <ul>
<li>I'm Ravern!</li>
<li>Year 3 Computer Science student</li>
<li>Interested in web development and programming languages</li>
<li>Learned Go ~4 years ago</li>
</ul>
<p><em>I'm <strong>not</strong> an expert in Go, I'm here to teach the basics of Go. Feel free to stop me if I'm saying incorrect stuff.</em></p>

      
      <span class="pagenumber">3</span>
      </article>
  
  
  
      <article >
      
        <h3>Background</h3>
        
<div class="image">
  <img src="images/gopher.png" width="100">
</div>
<ul>
<li>Designed at Google in 2009 (it's like old-new) by Robert Griesemer, Rob Pike, and Ken Thompson</li>
<li>Statically-typed, garbage collected, memory-safe</li>
<li>Compiles to binary executable, with strong support for cross compilation</li>
</ul>

      
      <span class="pagenumber">4</span>
      </article>
  
  
  
      <article >
      
        <h3>Why Go?</h3>
        <ul>
<li>It is <em>really</em> simple to learn</li>
<li>It provides both safety and speed</li>
<li>It has built-in support for concurrency</li>
<li>It has <em>fantastic</em> tooling</li>
</ul>

      
      <span class="pagenumber">5</span>
      </article>
  
  
  
      <article >
      
        <h3>Who&#39;s using Go?</h3>
        <p>Pretty much everyone.</p>

<div class="image">
  <img src="images/companies.png" height="320">
</div>
<p>It's also often used to build infrastructure tooling like <strong>Docker</strong> and <strong>Kubernetes</strong>.</p>

      
      <span class="pagenumber">6</span>
      </article>
  
  
  
      <article >
      
        <h2>Basics of Go</h2>
      
      <span class="pagenumber">7</span>
      </article>
  
  
  
      <article >
      
        <h3>Variables</h3>
        <pre><code>var anInt int = 42
aFloat := 3.14

var anotherInt, yetAnotherInt int = 1, 2
var (
    anotherFloat float64 = 4.321
    yetAnotherFloat float64 = 1.234
)
</code></pre>
<p>Notice that we have to declare the <em>type</em> of each variable, e.g., <code>int</code>, <code>float64</code>.</p>

      
      <span class="pagenumber">8</span>
      </article>
  
  
  
      <article >
      
        <h3>Primitive Data</h3>
        <pre><code>var aBool bool = true
var anUnsignedInt uint = 42
var anInt int = -42
var aFloat float64 = 3.14
var aComplex complex64 = complex(2, 3)
var aString string = &quot;This is a string!&quot;
</code></pre>
<p>What happens if I just do this?</p>
<pre><code>var aBool bool
var anInt int</code></pre>

      
      <span class="pagenumber">9</span>
      </article>
  
  
  
      <article >
      
        <h3>Functions</h3>
        <pre><code>func foo() {
    bar(32, &quot;one&quot;, &quot;two&quot;)
}

func bar(aParam int, anotherParam, yetAnotherParam string) {
    // Do something...
}

func baz() (string, string) {
    return &quot;foo&quot;, &quot;bar&quot;
}
</code></pre>
<p>Notice that there isn't a type definition for <code>anotherParam</code>.</p>

      
      <span class="pagenumber">10</span>
      </article>
  
  
  
      <article >
      
        <h3>Packages</h3>
        <pre><code>my_project
    ├── server.go
    ├── config.go
    ├── main.go
    ├── db
    │   ├── models.go
    │   └── connection.go
    └── auth
        ├── jwt.go
        ├── auth.go
        └── decrypt.go
</code></pre>
<ul>
<li>Go code is written in .go files</li>
<li>These files are grouped into directories</li>
<li>A directory is a Go package (all files have to declare the same package name)</li>
</ul>

      
      <span class="pagenumber">11</span>
      </article>
  
  
  
      <article >
      
        <h3>Hello, world</h3>
        <pre><code>package main

import &quot;fmt&quot;

func main() {
    fmt.Println(&quot;Hello, World!&quot;)
}</code></pre>

      
      <span class="pagenumber">12</span>
      </article>
  
  
  
      <article >
      
        <h3>Loops</h3>
        <p>Go only has the <code>for</code> loop, but it has different kinds.</p>
<p>There's the Java-style for loop.</p>
<pre><code>for i := 0; i &lt; 10; i++ {
    fmt.Printf(&quot;for loop iteration: %d\n&quot;, i)
}
</code></pre>
<p>And also the for-loop-that-should-really-be-a-while-loop.</p>
<pre><code>j := 0
for j &lt; 10 {
    fmt.Printf(&quot;while loop iteration: %d\n&quot;, j)
    j++
}</code></pre>

      
      <span class="pagenumber">13</span>
      </article>
  
  
  
      <article >
      
        <h3>Loops</h3>
        <p>There's also the infinite for loop. Usually you'd have a <code>break</code> somewhere in the loop in order to stop it.</p>
<pre><code>k := 0
for {
    fmt.Printf(&quot;infinite loop iteration: %d\n&quot;, k)
    k++
}</code></pre>

      
      <span class="pagenumber">14</span>
      </article>
  
  
  
      <article >
      
        <h3>Conditionals</h3>
        <p>For conditionals, we have the <code>if</code> and <code>switch</code> statements.</p>
<p>The if statement looks pretty normal.</p>
<pre><code>if x &gt; 5 {
    fmt.Println(&quot;x is greater than 5&quot;)
} else {
    fmt.Println(&quot;x is less than or equal to 5&quot;)
}
</code></pre>
<p>We can also initialize a variable before the condition!</p>
<pre><code>if y := 1; y &gt; 0 {
    fmt.Println(&quot;y is positive&quot;)
} else {
    fmt.Println(&quot;y is non-positive&quot;)
}</code></pre>

      
      <span class="pagenumber">15</span>
      </article>
  
  
  
      <article >
      
        <h3>Conditionals</h3>
        <p>We also have the switch statement.</p>
<pre><code>switch x {
case 1:
    fmt.Println(&quot;x is just 1&quot;)
case 2, 3, 4:
    fmt.Println(&quot;x must be 2, 3, or 4&quot;)
    fallthrough
case 5, 6, 7:
    fmt.Println(&quot;x must be between 2 and 7 (inclusive)&quot;)
}
</code></pre>
<p>Notice how that the cases don't fall through by default, unlike in C or Java. Instead, we have to explicitly tell it to <code>fallthrough</code>.</p>

      
      <span class="pagenumber">16</span>
      </article>
  
  
  
      <article >
      
        <h3>Conditionals</h3>
        <p>You can also have switch statements without a condition. It's equivalent to a long chain of if-else statements.</p>
<pre><code>switch {
case x &lt; 5:
    fmt.Println(&quot;x is smaller than 5&quot;)
case x == 5:
    fmt.Println(&quot;x is 5&quot;)
case x &gt; 5:
    fmt.Println(&quot;x is greater than 5&quot;)
}</code></pre>

      
      <span class="pagenumber">17</span>
      </article>
  
  
  
      <article >
      
        <h3>Pointers</h3>
        <p>Go has pointers.</p>
<p>Pointers store the location of the underlying value, e.g., an int pointer (<code>*int</code>) stores the location of an integer in memory.</p>
<pre><code>var x, y int = 10, 20
fmt.Println(&quot;x =&quot;, x)
fmt.Println(&quot;y =&quot;, y)

var ptr *int = &amp;x
fmt.Println(&quot;ptr =&quot;, ptr)
fmt.Println(&quot;*ptr =&quot;, *ptr)

*ptr = 30
fmt.Println(&quot;ptr =&quot;, ptr)
fmt.Println(&quot;*ptr =&quot;, *ptr)

ptr = &amp;y
fmt.Println(&quot;ptr =&quot;, ptr)
fmt.Println(&quot;*ptr =&quot;, *ptr)</code></pre>

      
      <span class="pagenumber">18</span>
      </article>
  
  
  
      <article >
      
        <h3>Pointers</h3>
        <p>Passing pointers to functions allows you to modify the underlying variable.</p>
<pre><code>func setToHundred(x int) {
    x = 100
}

func setToHundredWithPtr(x *int) {
    *x = 100
}

func main() {
    x := 10

    setToHundred(x)
    fmt.Println(&quot;x =&quot;, x)

    setToHundredWithPtr(&amp;x)
    fmt.Println(&quot;x =&quot;, x)
}</code></pre>

      
      <span class="pagenumber">19</span>
      </article>
  
  
  
      <article >
      
        <h3>Pointers</h3>
        <p>The zero value for pointers is <code>nil</code>.</p>
<pre><code>var x *int
fmt.Println(x)
</code></pre>
<p>What happens when you try to modify a pointer whose value is <code>nil</code>?</p>

      
      <span class="pagenumber">20</span>
      </article>
  
  
  
      <article >
      
        <h3>Arrays</h3>
        <p>Arrays are a collection of items that have a <strong>fixed-size</strong>.</p>
<pre><code>var anIntArray [5]int = [5]int{1, 2, 3, 4, 5}
var aBoolArray [5]bool = [5]bool{true, false, true, false, true}
var aStringArray [5]string = [5]string{&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;}

fmt.Println(&quot;anIntArray =&quot;, anIntArray)
fmt.Println(&quot;aBoolArray =&quot;, aBoolArray)
fmt.Println(&quot;aStringArray =&quot;, aStringArray)</code></pre>

      
      <span class="pagenumber">21</span>
      </article>
  
  
  
      <article >
      
        <h3>Slices</h3>
        <p>Slices are a collection of items that have a no fixed size. They can be dynamically resized.</p>
<pre><code>anArray := [7]int{1, 2, 3, 4, 5, 6, 7}

var aSlice []int = anArray[1:5]
fmt.Println(&quot;aSlice =&quot;, aSlice)

anotherSlice := anArray[2:6]
fmt.Println(&quot;anotherSlice =&quot;, anotherSlice)

anImmediateSlice := []int{1, 2, 3, 4, 5}
fmt.Println(&quot;anImmediateSlice =&quot;, anImmediateSlice)</code></pre>

      
      <span class="pagenumber">22</span>
      </article>
  
  
  
      <article >
      
        <h3>Slices</h3>
        <p>Since slices are dynamically sized, we can append to them. <code>append</code> does <strong>not</strong> modify the given slice but instead returns a new one.</p>
<pre><code>aSlice := []int{1, 2, 3, 4, 5}
aSlice = append(aSlice, 6)

anotherSlice := append(aSlice, 7)

fmt.Println(&quot;aSlice =&quot;, aSlice)
fmt.Println(&quot;anotherSlice =&quot;, anotherSlice)</code></pre>

      
      <span class="pagenumber">23</span>
      </article>
  
  
  
      <article >
      
        <h3>Slices</h3>
        <p>To make an empty slice, use <code>make</code> function.</p>
<pre><code>aSlice := make([]int, 10, 500)
fmt.Println(&quot;aSlice =&quot;, aSlice)
</code></pre>
<p>What's that second parameter (<code>500</code>) for?</p>

      
      <span class="pagenumber">24</span>
      </article>
  
  
  
      <article >
      
        <h3>Slices</h3>
        <p>There is yet another type of for loop that can more easily loop through slices. This is the <strong>for-range</strong> loop.</p>
<pre><code>aSlice := []int{6, 7, 8, 9, 10}

for i := range aSlice {
    fmt.Println(&quot;The index is&quot;, i)
}

for i, item := range aSlice {
    fmt.Println(&quot;The index is&quot;, i, &quot;and the item is&quot;, item)
}</code></pre>

      
      <span class="pagenumber">25</span>
      </article>
  
  
  
      <article >
      
        <h3>Maps</h3>
        <p>Maps store key-value pairs, in order to map keys to values.</p>
<pre><code>var aMap map[string]int = map[string]int{
    &quot;one&quot;:   1,
    &quot;two&quot;:   2,
    &quot;three&quot;: 3,
}

fmt.Println(&quot;aMap =&quot;, aMap)

fmt.Println(&quot;aMap[\&quot;one\&quot;] =&quot;, aMap[&quot;one&quot;])
fmt.Println(&quot;aMap[\&quot;two\&quot;] =&quot;, aMap[&quot;two&quot;])
fmt.Println(&quot;aMap[\&quot;three\&quot;] = aMap[&quot;three&quot;])</code></pre>

      
      <span class="pagenumber">26</span>
      </article>
  
  
  
      <article >
      
        <h3>Maps</h3>
        <p>We can check if keys exist in a map by getting a <code>bool</code> as a second return value.</p>
<pre><code>aMap := map[string]int{
    &quot;one&quot;:   1,
    &quot;two&quot;:   2,
    &quot;three&quot;: 3,
}

three, ok := aMap[&quot;three&quot;]
fmt.Println(&quot;aMap[\&quot;three\&quot;] =&quot;, three, ok)

four, ok := aMap[&quot;four&quot;]
fmt.Println(&quot;aMap[\&quot;four\&quot;] =&quot;, four, ok)</code></pre>

      
      <span class="pagenumber">27</span>
      </article>
  
  
  
      <article >
      
        <h3>Maps</h3>
        <p>You can use <code>delete</code> to remove key-value pairs from maps.</p>
<pre><code>aMap := map[string]int{
    &quot;one&quot;:   1,
    &quot;two&quot;:   2,
    &quot;three&quot;: 3,
}

delete(aMap, &quot;three&quot;)

three, ok := aMap[&quot;three&quot;]
fmt.Println(&quot;aMap[\&quot;three\&quot;] =&quot;, three, ok)</code></pre>

      
      <span class="pagenumber">28</span>
      </article>
  
  
  
      <article >
      
        <h3>Maps</h3>
        <p>Similar to slices, use the <code>make</code> function to create an empty map.</p>
<pre><code>aMap := make(map[string]int)
aMap[&quot;one&quot;] = 1
aMap[&quot;two&quot;] = 2
aMap[&quot;three&quot;] = 3

fmt.Println(&quot;aMap =&quot;, aMap)</code></pre>

      
      <span class="pagenumber">29</span>
      </article>
  
  
  
      <article >
      
        <h3>Maps</h3>
        <p>You can also use the range-based for loop with maps.</p>
<pre><code>aMap := map[string]int{
    &quot;one&quot;:   1,
    &quot;two&quot;:   2,
    &quot;three&quot;: 3,
}

for key := range aMap {
    fmt.Println(&quot;The key is&quot;, key)
}

for key, value := range aMap {
    fmt.Println(&quot;The key is&quot;, key, &quot;and the value is&quot;, value)
}</code></pre>

      
      <span class="pagenumber">30</span>
      </article>
  
  
  
      <article >
      
        <h3>Exercise</h3>
        <p>Let's write a program that counts the number of times each word in <code>words</code> appears in <code>passage</code>, and prints the counts to the console.</p>
<p><em>Hint: Check out the <code>strings.Fields</code> function.</em></p>

      
      <span class="pagenumber">31</span>
      </article>
  
  
  
      <article >
      
        <h2>Data Composition in Go</h2>
      
      <span class="pagenumber">32</span>
      </article>
  
  
  
      <article >
      
        <h3>Structs</h3>
        <p>We can use structs to group related pieces of data.</p>
<pre><code>type person struct {
    firstName string
    lastName  string
    age       int
}

func main() {
    var p person = person{
        firstName: &quot;John&quot;,
        lastName:  &quot;Doe&quot;,
        age:       30,
    }

    fmt.Println(p)
}</code></pre>

      
      <span class="pagenumber">33</span>
      </article>
  
  
  
      <article >
      
        <h3>Structs</h3>
        <p>Structs can have methods, which act on the struct and can be called with the struct as the receiver.</p>
<pre><code>func (p person) fullName() string {
    return p.firstName + &quot; &quot; + p.lastName
}

func main() {
    var p person = person{
        firstName: &quot;Jane&quot;,
        lastName:  &quot;Doe&quot;,
        age:       30,
    }

    fmt.Println(p.fullName())
}</code></pre>

      
      <span class="pagenumber">34</span>
      </article>
  
  
  
      <article >
      
        <h3>Structs</h3>
        <p>Structs are copied. This means that modifying them won't work by default.</p>
<pre><code>func (p person) growOlder(years int) {
    p.age += years
}

func changeFirstName(p person, newFirstName string) {
    p.firstName = newFirstName
}

func main() {
    var p person = person{
        firstName: &quot;Jane&quot;,
        lastName:  &quot;Doe&quot;,
        age:       30,
    }

    p.growOlder(1)
    changeFirstName(p, &quot;John&quot;)

    fmt.Println(p.fullName(), &quot;is&quot;, p.age, &quot;years old&quot;)
}</code></pre>

      
      <span class="pagenumber">35</span>
      </article>
  
  
  
      <article >
      
        <h3>Structs</h3>
        <p>How do we modify them then? We can use <strong>pointers</strong>.</p>
<pre><code>func (p *person) growOlder(years int) {
    p.age += years
}

func changeFirstName(p *person, newFirstName string) {
    p.firstName = newFirstName
}

func main() {
    var p person = person{
        firstName: &quot;Jane&quot;,
        lastName:  &quot;Doe&quot;,
        age:       30,
    }

    p.growOlder(1)
    changeFirstName(&amp;p, &quot;John&quot;)

    fmt.Println(p.fullName(), &quot;is&quot;, p.age, &quot;years old&quot;)
}</code></pre>

      
      <span class="pagenumber">36</span>
      </article>
  
  
  
      <article >
      
        <h3>Interfaces</h3>
        <p>We can use interfaces to group related pieces of behaviour.</p>
<p>This interface defines a behaviour that any data that has the <code>area</code> and <code>perimeter</code> methods is a <code>shape</code>.</p>
<pre><code>type shape interface {
    perimeter() int
    area() int
}</code></pre>

      
      <span class="pagenumber">37</span>
      </article>
  
  
  
      <article >
      
        <h3>Interfaces</h3>
        <p>We can then define structs that implement this behaviour.</p>
<p>Here's a square.</p>
<pre><code>type square struct {
    size int
}

func (s square) perimeter() int {
    return s.size * 4
}

func (s square) area() int {
    return s.size * s.size
}</code></pre>

      
      <span class="pagenumber">38</span>
      </article>
  
  
  
      <article >
      
        <h3>Interfaces</h3>
        <p>And here's a rectangle.</p>
<pre><code>type rect struct {
    length int
    breadth int
}

func (r rect) perimeter() int {
    return (r.length + r.breadth) * 2
}

func (r rect) area() int {
    return r.length * r.breadth
}</code></pre>

      
      <span class="pagenumber">39</span>
      </article>
  
  
  
      <article >
      
        <h3>Interfaces</h3>
        <p>We can define a function that acts on a <code>shape</code> (and not specifically on a <code>square</code> or <code>rect</code>).</p>
<pre><code>func printShape(s shape) {
    fmt.Println(&quot;The area of the shape is&quot;, s.area(), &quot;and the perimeter is&quot;, s.perimeter())
}

func main() {
    s := square{size: 10}
    r := rect{length: 5, breadth: 10}

    printShape(s)
    printShape(r)
}</code></pre>

      
      <span class="pagenumber">40</span>
      </article>
  
  
  
      <article >
      
        <h3>Interfaces</h3>
        <p>How do we know what's the concrete type (i.e., square, circle) stored inside the interface (i.e., shape)?</p>
<p>We can perform a <strong>type switch</strong>.</p>
<pre><code>switch s.(type) {
case square:
    fmt.Println(&quot;s is a square&quot;)
case rect:
    fmt.Println(&quot;s is a rect&quot;)
}</code></pre>

      
      <span class="pagenumber">41</span>
      </article>
  
  
  
      <article >
      
        <h3>Interfaces</h3>
        <p>If we already know the concrete type, and we want to <em>get</em> a variable of that type, we can perform a <strong>type assertion</strong>.</p>
<pre><code>thisIsASquare, ok := s.(square)
if ok {
    fmt.Println(&quot;The size of the square is&quot;, thisIsASquare.size)
}</code></pre>

      
      <span class="pagenumber">42</span>
      </article>
  
  
  
      <article >
      
        <h3>Exercises</h3>
        <p>Let's write a program to process payments from a few different payment methods.</p>

      
      <span class="pagenumber">43</span>
      </article>
  
  
  
      <article >
      
        <h2>Concurrency and Parallelism in Go</h2>
      
      <span class="pagenumber">44</span>
      </article>
  
  
  
      <article >
      
        <h3>Goroutines</h3>
        <p>These are the unit of concurrency in Go. Spawning a new goroutine is starting a new thread of concurrent execution.</p>
<pre><code>import (
    &quot;fmt&quot;
    &quot;time&quot;
)

func countToTen(name string) {
    for i := 0; i &lt; 10; i++ {
        fmt.Println(name, &quot;-&quot;, i)
        time.Sleep(1 * time.Second)
    }
}

func main() {
    go countToTen(&quot;foo&quot;)
    go countToTen(&quot;bar&quot;)
    time.Sleep(11 * time.Second)
}</code></pre>

      
      <span class="pagenumber">45</span>
      </article>
  
  
  
      <article >
      
        <h3>Goroutines</h3>
        <p>Go has support for true parallelism by distributing these goroutines across multiple threads.</p>
<p>But as a result we can't just do operations that might be thread-unsafe. This is a much simplified example of what might go wrong.</p>
<pre><code>func modifyData(data map[int]int) {
    for i := 0; i &lt; 10000; i++ {
        data[0] = i
    }
}

func main() {
    data := make(map[int]int)
    go modifyData(data)
    go modifyData(data)
    time.Sleep(2 * time.Second)
    fmt.Println(&quot;done!&quot;)
}</code></pre>

      
      <span class="pagenumber">46</span>
      </article>
  
  
  
      <article >
      
        <h3>Channels</h3>
        <p>We need a safe way of passing data around without causing issues like that. This is where channels come into play.</p>
<blockquote>
<p><em>Don't communicate by sharing memory; share memory by communicating ~ Rob Pike</em></p>
</blockquote>
<p>Channels provide a safe way to send and receive data across goroutines.</p>
<pre><code>messages := make(chan string)

// in some goroutine, we send a message
messages &lt;- message

// in another goroutine, we receive the mesasge
message := &lt;-messages</code></pre>

      
      <span class="pagenumber">47</span>
      </article>
  
  
  
      <article >
      
        <h3>Channels</h3>
        <pre><code>func readMessages(messages &lt;-chan string) {
    for m := range messages {
        fmt.Println(&quot;Received message:&quot;, m)
    }
}

func sendMessages(messages chan&lt;- string) {
    messages &lt;- &quot;Hello, world!&quot;
    time.Sleep(time.Second)
    messages &lt;- &quot;Today we are sending and receiving messages with a channel.&quot;
    time.Sleep(time.Second)
    messages &lt;- &quot;This will be fun!&quot;
    close(messages)
}

func main() {
    messages := make(chan string)
    go sendMessages(messages)
    readMessages(messages)
}</code></pre>

      
      <span class="pagenumber">48</span>
      </article>
  
  
  
      <article >
      
        <h3>Channels</h3>
        <p>We can use the <code>select</code> statement in Go to pull the first result from one or more different channels.</p>
<pre><code>c1 := make(chan string)
c2 := make(chan string)

select {
case msg1 := &lt;-c1:
    fmt.Println(&quot;received from channel 1&quot;)
case msg1 := &lt;-c2:
    fmt.Println(&quot;received from channel 2&quot;)
}</code></pre>

      
      <span class="pagenumber">49</span>
      </article>
  
  
  
      <article >
      
        <h3>Channels</h3>
        <p>What happens when we send a value to a channel that no one's receiving on?</p>
<p><strong>We can't do that.</strong> Or rather, the goroutine trying to send a message will just block until another goroutine chooses to receive from that channel.</p>
<p>This could be quite inconvenient behaviour, since we kind of want the channel to store these values for later use.</p>
<p>We can use <strong>buffered channels</strong> for this purpose.</p>
<pre><code>messages := make(chan string, 5)
</code></pre>
<p>This channel can store 5 messages. The 6th one will still block the goroutine.</p>

      
      <span class="pagenumber">50</span>
      </article>
  
  
  
      <article >
      
        <h3>Exercise</h3>
        <p>Let's write a program to &quot;download&quot; videos concurrently.</p>
<p>But there's a catch! You can only download up to a certain number of videos at the same time, otherwise the program will crash.</p>
<p>Obviously, you shouldn't be downloading them one-by-one either.</p>

      
      <span class="pagenumber">51</span>
      </article>
  
  

      <article>
        <h3>Thank you</h3>
        
          <div class="presenter">
            
  
  <p>
    Ravern Koh
  </p>
  

  
  <p>
    NUS Hackers
  </p>
  
<p class="link"><a href="mailto:ravern@nushackers.org" target="_blank">ravern@nushackers.org</a></p><p class="link"><a href="http://twitter.com/ravernkoh" target="_blank">@ravernkoh</a></p>
          </div>
        
      </article>

    </section>

    <div id="help">
      Use the left and right arrow keys or click the left and right
      edges of the page to navigate between slides.<br>
      (Press 'H' or navigate to hide this message.)
    </div>

    
    

    <script>
      (function() {
        
        if (window["location"] && window["location"]["hostname"] == "talks.golang.org") {
          var ga = document.createElement("script"); ga.type = "text/javascript"; ga.async = true;
          ga.src = ("https:" == document.location.protocol ? "https://ssl" : "http://www") + ".google-analytics.com/ga.js";
          var s = document.getElementsByTagName("script")[0]; s.parentNode.insertBefore(ga, s);
        }
      })();
    </script>
  </body>
</html>
